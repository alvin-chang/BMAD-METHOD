# Story 1.1: Project Setup and Infrastructure

## Status

Draft

## Story

**As a** developer,
**I want** a properly structured Rust project with CI/CD pipelines,
**so that** I can ensure code quality and automated releases from the start.

## Acceptance Criteria

1. Repository initialized with Rust project structure and .gitignore
2. Cargo.toml configured with project metadata and all required dependencies from tech stack
3. GitHub Actions workflow for CI (test, lint, build) on all platforms
4. GitHub Actions workflow for CD (release binaries) on tag push
5. Basic README with project description and development setup instructions
6. Pre-commit hooks configured for formatting (rustfmt) and linting (clippy)
7. MIT License file added
8. Makefile with common development commands (test, build, release)

## Tasks / Subtasks

- [ ] Task 1: Initialize Rust project structure (AC: 1)
  - [ ] Create Cargo.toml with project metadata
  - [ ] Set up proper .gitignore for Rust projects
  - [ ] Initialize git repository if needed
  - [ ] Create basic src/main.rs entry point
- [ ] Task 2: Configure dependencies in Cargo.toml (AC: 2)
  - [ ] Add clap v4.5.4 for CLI framework
  - [ ] Add sqlx v0.7.4 for database operations
  - [ ] Add anyhow v1.0.82 for error handling
  - [ ] Add thiserror v1.0.58 for custom error types
  - [ ] Add toml v0.8.12 for config file parsing
  - [ ] Add termcolor v1.4.1 for colored output
  - [ ] Add criterion v0.5.1 for benchmarking
  - [ ] Add env_logger v0.11.3 for debug logging
  - [ ] Add chrono v0.4.38 and chrono-english v0.1.7 for date parsing
  - [ ] Add serde v1.0.197 for serialization
- [ ] Task 3: Set up GitHub Actions CI workflow (AC: 3)
  - [ ] Create .github/workflows/ci.yml
  - [ ] Configure test, lint, and build jobs
  - [ ] Set up matrix builds for Linux and macOS
  - [ ] Add rustfmt and clippy checks
  - [ ] Add security audit using cargo audit
  - [ ] Add performance benchmarks with 5% regression threshold
- [ ] Task 4: Set up GitHub Actions CD workflow (AC: 4)
  - [ ] Create .github/workflows/release.yml
  - [ ] Configure binary builds for release
  - [ ] Set up artifact uploads for releases
  - [ ] Configure triggering on tag push
- [ ] Task 5: Create project documentation (AC: 5)
  - [ ] Write README.md with project description
  - [ ] Add development setup instructions
  - [ ] Document build and test commands
  - [ ] Include installation instructions
- [ ] Task 6: Configure pre-commit hooks (AC: 6)
  - [ ] Set up rustfmt pre-commit hook
  - [ ] Set up clippy pre-commit hook
  - [ ] Document hook setup in README
- [ ] Task 7: Add MIT License (AC: 7)
  - [ ] Create LICENSE file with MIT license text
  - [ ] Add license field to Cargo.toml
- [ ] Task 8: Create Makefile for development (AC: 8)
  - [ ] Add test target
  - [ ] Add build target (debug and release)
  - [ ] Add lint target (rustfmt + clippy)
  - [ ] Add clean target

## Dev Notes

### Previous Story Insights

No previous story exists - this is the first story in the project.

### Technical Architecture Context

**Project Structure Requirements** [Source: architecture.md#source-tree]:

- Follow the defined monorepo structure with clear separation of concerns
- Implement clean architecture layers: CLI, Application, Domain, Infrastructure
- Use the exact directory structure specified in the architecture document

**Technology Stack Requirements** [Source: architecture.md#tech-stack]:

- **Language**: Rust 1.78.0 (2021 edition)
- **CLI Framework**: clap v4.5.4 for command-line parsing
- **Database**: sqlx v0.7.4 for SQLite operations
- **Error Handling**: anyhow v1.0.82 for application errors, thiserror v1.0.58 for custom types
- **Configuration**: toml v0.8.12 for config file parsing
- **Terminal Output**: termcolor v1.4.1 for colored output
- **Testing**: criterion v0.5.1 for benchmarking
- **Logging**: env_logger v0.11.3 for debug logging
- **Date Parsing**: chrono v0.4.38, chrono-english v0.1.7
- **Serialization**: serde v1.0.197 for JSON/CSV export

**Performance Requirements** [Source: architecture.md#high-level-architecture]:

- Sub-100ms command execution requirement
- Cold start application startup < 50ms
- Memory usage must not exceed 10MB during normal operation
- Single binary distribution with no runtime dependencies
- Synchronous execution model (no async runtime overhead)
- Static linking required for zero runtime dependencies

**Build and CI Requirements** [Source: architecture.md#infrastructure-and-deployment]:

- GitHub Actions for CI/CD pipeline
- Matrix builds for Linux and macOS platforms
- Automated binary releases on tag push
- Integration with cargo, rustfmt, and clippy
- Security audit using cargo audit in CI pipeline
- Performance benchmarks with 5% regression threshold
- LTO enabled for release builds
- Binary size optimization for releases

### File Locations

Based on the architecture document, the complete project structure should be:

```
termtodo/
├── Cargo.toml                 # Project manifest with dependencies
├── Cargo.lock                # Locked dependency versions
├── build.rs                   # Build script for embedding resources
├── .github/
│   └── workflows/
│       ├── ci.yml            # Test, lint, build on all platforms
│       └── release.yml       # Build and publish binaries on tag
├── src/
│   ├── main.rs              # Entry point, CLI setup
│   ├── cli/
│   │   ├── mod.rs           # CLI module exports
│   │   ├── parser.rs        # Clap command definitions
│   │   └── commands/        # Command handlers
│   ├── app/
│   │   ├── mod.rs           # Application layer exports
│   │   ├── service.rs       # Main application service
│   │   └── errors.rs        # Application error types
│   ├── domain/
│   │   ├── mod.rs           # Domain model exports
│   │   ├── task.rs          # Task entity
│   │   └── types.rs         # Enums (Status, Priority)
│   ├── infra/
│   │   ├── mod.rs           # Infrastructure exports
│   │   ├── db/             # Database module
│   │   ├── repos/          # Repository implementations
│   │   └── config/         # Config file handling
│   └── utils/
│       ├── mod.rs           # Utility exports
│       ├── dates.rs         # Date parsing helpers
│       └── result.rs        # Result extensions
├── tests/
│   ├── integration/         # Integration tests
│   └── fixtures/            # Test data files
├── benches/
│   └── performance.rs       # Criterion benchmarks
├── migrations/              # SQL migration files
├── LICENSE                  # MIT license file
├── Makefile                 # Development commands
└── README.md               # Project documentation
```

### Testing Requirements

**Testing Standards** [Source: architecture.md#test-strategy-and-standards]:

- Use Rust built-in testing framework
- Target 80% overall coverage, 90% for business logic
- Unit tests in `#[cfg(test)]` modules within source files
- Integration tests in `tests/integration/` directory
- Performance tests using criterion benchmarks
- Pre-commit hooks for formatting and linting validation

### Technical Constraints

**Coding Standards** [Source: architecture.md#coding-standards]:

- Rust 1.78.0 with 2021 edition
- rustfmt with default configuration
- clippy with pedantic lints enabled
- No unwrap() in production code
- All public functions must have doc comments
- Parameterized SQL statements only

**Error Handling** [Source: architecture.md#error-handling-strategy]:

- Result<T, Error> for all fallible operations
- anyhow::Error for applications, custom types for libraries
- Error propagation using ? operator with context

### Database Configuration Requirements

**SQLite PRAGMA Settings** [Source: architecture.md#database-requirements]:

- foreign_keys=ON for referential integrity
- journal_mode=WAL for performance
- synchronous=NORMAL for balanced safety/performance
- Connection pooling and prepared statement caching
- Schema migration system with version tracking
- Optimized indexes for common query patterns

### Clean Architecture Layer Requirements

**Layer Separation** [Source: architecture.md#clean-architecture]:

- **CLI Layer**: Command parsing and output formatting only
- **Application Layer**: Business logic orchestration
- **Domain Layer**: Core entities and business rules
- **Infrastructure Layer**: Database, config, external concerns
- Repository pattern for data access abstraction
- Command pattern for CLI subcommand handlers

### Testing

**Testing Standards** [Source: architecture.md#test-strategy-and-standards]:

**Framework**: Rust built-in testing framework
**Coverage Goals**:

- 80% overall coverage minimum
- 90% for business logic coverage minimum
- Test pyramid: 70% unit, 25% integration, 5% e2e

**Test Organization**:

- Unit tests in `#[cfg(test)]` modules within source files
- Integration tests in `tests/integration/` directory
- End-to-end tests using assert_cmd for CLI testing
- Performance tests using criterion benchmarks

**Testing Infrastructure**:

- Use tempfile crate for isolated file system testing
- In-memory SQLite for database integration tests
- Criterion benchmarks for performance regression testing
- assert_cmd for CLI end-to-end testing

**CI Requirements**:

- Run tests on every push and pull request
- Include rustfmt and clippy checks in CI pipeline
- Performance benchmarks with 5% regression threshold
- Security audit using cargo audit
- Cross-platform testing (Linux and macOS)

## Change Log

| Date       | Version | Description                                                                                                          | Author                |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------------------- | --------------------- |
| 2025-07-07 | 1.0     | Initial story creation                                                                                               | Bob (Scrum Master)    |
| 2025-07-07 | 1.1     | Fixed validation issues: complete dependency list, template structure, performance requirements, source tree details | Sarah (Product Owner) |

## Dev Agent Record

_This section will be populated by the development agent during implementation_

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_Results from QA Agent review will be populated here_
